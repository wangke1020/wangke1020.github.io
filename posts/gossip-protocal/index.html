<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>Gossip Protocal - iofun</title><meta name=Description content><meta property="og:title" content="Gossip Protocal">
<meta property="og:description" content="什么是Gossip协议 Gossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。
Epidemiology 流行病传染最基本的模型仅作如下几个假设：
 (n+1)个人均匀的分布在一起 每一对人群之间的传染概率是$\beta$，显然$0<\beta<1$. 任意时刻，某个人要么处于infected的状态要么处于uninfected的状态. 一旦某个人从uninfected状态转变成为infected状态，其一直停留在infected状态。  有了以上假设，我们可以进一步分析流行病的传染情况。我们记t时刻处于infected状态的人数为$y_t$，处于uninfected状态的人为$x_t$，那么初始状态 $y_0=1$, $x_0=n$，并且在任何时候$x_t+y_t=n+1$.
考虑连续的时间，可知：
 $\frac{dx}{dt}=−βxy$
 解为：
 $x=\frac{n(n+1)}{n+e^{β(n+1)t}}$ $y=\frac{n+1}{1+ne^{−β(n+1)t}}$
 明显，当$t→∞$时，$x→0,y→(n+1)x→0,y→(n+1)$，即经过足够的时间，所有的人都将被传染。
如果每个人每次传染的人数是b,那么
 $\beta=\frac{b}{n}$
 令 t=$clog(n)$,可以得到 $y\approx(n+1)-\frac{1}{n^{cb-2}}$
这表明，仅需要$O(log(n))$个回合，gossip协议即可将信息传递到所有的节点。 根据分析可得，Gossip协议具有以下的特点:
 低延迟。仅仅需要$O(log(n))$个回合的传递时间。 非常可靠。仅有$\frac{1}{n^{cb-2}}$个节点不会收到信息。 轻量级。每个节点传送了$cblog(n)$次信息。  于此同时，Gossip协议的容错性比较高，例如，50的丢包率等价于使用b/2b带代替b进行分析；50的节点错误等价于使用n/2来代替nn，同时使用b/2来代替b进行分析，其分析结果不用带来数量级上的变化。
Gossip节点的通信方式 根据原论文，两个节点（A、B）之间存在三种通信方式:
 push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据 pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地 push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地  如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。
假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(log(n))$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第$i$个周期被感染的概率为$P_i$ ,第$i+1$个周期被感染的概率为$P^{i+1}$ ，则pull的方式:
 $P_{i+1}=P_i^{b+1}$
 而push为：
 $P_{i+1}=P_i(1-\frac{1}{n})^{n(1-P_i)}$
 显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0<p<1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://iofun.me/posts/gossip-protocal/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-04-26T21:23:51+00:00">
<meta property="article:modified_time" content="2017-04-26T21:23:51+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Gossip Protocal">
<meta name=twitter:description content="什么是Gossip协议 Gossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。
Epidemiology 流行病传染最基本的模型仅作如下几个假设：
 (n+1)个人均匀的分布在一起 每一对人群之间的传染概率是$\beta$，显然$0<\beta<1$. 任意时刻，某个人要么处于infected的状态要么处于uninfected的状态. 一旦某个人从uninfected状态转变成为infected状态，其一直停留在infected状态。  有了以上假设，我们可以进一步分析流行病的传染情况。我们记t时刻处于infected状态的人数为$y_t$，处于uninfected状态的人为$x_t$，那么初始状态 $y_0=1$, $x_0=n$，并且在任何时候$x_t+y_t=n+1$.
考虑连续的时间，可知：
 $\frac{dx}{dt}=−βxy$
 解为：
 $x=\frac{n(n+1)}{n+e^{β(n+1)t}}$ $y=\frac{n+1}{1+ne^{−β(n+1)t}}$
 明显，当$t→∞$时，$x→0,y→(n+1)x→0,y→(n+1)$，即经过足够的时间，所有的人都将被传染。
如果每个人每次传染的人数是b,那么
 $\beta=\frac{b}{n}$
 令 t=$clog(n)$,可以得到 $y\approx(n+1)-\frac{1}{n^{cb-2}}$
这表明，仅需要$O(log(n))$个回合，gossip协议即可将信息传递到所有的节点。 根据分析可得，Gossip协议具有以下的特点:
 低延迟。仅仅需要$O(log(n))$个回合的传递时间。 非常可靠。仅有$\frac{1}{n^{cb-2}}$个节点不会收到信息。 轻量级。每个节点传送了$cblog(n)$次信息。  于此同时，Gossip协议的容错性比较高，例如，50的丢包率等价于使用b/2b带代替b进行分析；50的节点错误等价于使用n/2来代替nn，同时使用b/2来代替b进行分析，其分析结果不用带来数量级上的变化。
Gossip节点的通信方式 根据原论文，两个节点（A、B）之间存在三种通信方式:
 push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据 pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地 push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地  如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。
假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(log(n))$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第$i$个周期被感染的概率为$P_i$ ,第$i+1$个周期被感染的概率为$P^{i+1}$ ，则pull的方式:
 $P_{i+1}=P_i^{b+1}$
 而push为：
 $P_{i+1}=P_i(1-\frac{1}{n})^{n(1-P_i)}$
 显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0<p<1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。">
<meta name=application-name content="iofun">
<meta name=apple-mobile-web-app-title content="iofun"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://iofun.me/posts/gossip-protocal/><link rel=prev href=https://iofun.me/posts/fork-and-pipe/><link rel=next href=https://iofun.me/posts/cap%E7%90%86%E8%AE%BA/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Gossip Protocal","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/iofun.me\/posts\/gossip-protocal\/"},"genre":"posts","wordcount":43,"url":"https:\/\/iofun.me\/posts\/gossip-protocal\/","datePublished":"2017-04-26T21:23:51+00:00","dateModified":"2017-04-26T21:23:51+00:00","publisher":{"@type":"Organization","name":"Author"},"author":{"@type":"Person","name":"Author"},"description":""}</script></head>
<body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=iofun>iofun</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/> Home </a><a class=menu-item href=/posts> All posts </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=iofun>iofun</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/ title>Home</a><a class=menu-item href=/posts title>All posts</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">Gossip Protocal</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Author</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2017-04-26>2017-04-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;43 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;One minute&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><h4 id=什么是gossip协议>什么是Gossip协议</h4>
<p>Gossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。</p>
<h4 id=epidemiology>Epidemiology</h4>
<p>流行病传染最基本的模型仅作如下几个假设：</p>
<ol>
<li>(n+1)个人均匀的分布在一起</li>
<li>每一对人群之间的传染概率是$\beta$，显然$0&lt;\beta&lt;1$.</li>
<li>任意时刻，某个人要么处于infected的状态要么处于uninfected的状态.</li>
<li>一旦某个人从uninfected状态转变成为infected状态，其一直停留在infected状态。</li>
</ol>
<p>有了以上假设，我们可以进一步分析流行病的传染情况。我们记t时刻处于infected状态的人数为$y_t$，处于uninfected状态的人为$x_t$，那么初始状态 $y_0=1$, $x_0=n$，并且在任何时候$x_t+y_t=n+1$.</p>
<p>考虑连续的时间，可知：</p>
<blockquote>
<p>$\frac{dx}{dt}=−βxy$</p>
</blockquote>
<p>解为：</p>
<blockquote>
<p>$x=\frac{n(n+1)}{n+e^{β(n+1)t}}$
$y=\frac{n+1}{1+ne^{−β(n+1)t}}$</p>
</blockquote>
<p>明显，当$t→∞$时，$x→0,y→(n+1)x→0,y→(n+1)$，即经过足够的时间，所有的人都将被传染。</p>
<p>如果每个人每次传染的人数是b,那么</p>
<blockquote>
<p>$\beta=\frac{b}{n}$</p>
</blockquote>
<p>令 t=$clog(n)$,可以得到 $y\approx(n+1)-\frac{1}{n^{cb-2}}$</p>
<p>这表明，仅需要$O(log(n))$个回合，gossip协议即可将信息传递到所有的节点。 根据分析可得，Gossip协议具有以下的特点:</p>
<ol>
<li>低延迟。仅仅需要$O(log(n))$个回合的传递时间。</li>
<li>非常可靠。仅有$\frac{1}{n^{cb-2}}$个节点不会收到信息。</li>
<li>轻量级。每个节点传送了$cblog(n)$次信息。</li>
</ol>
<p>于此同时，Gossip协议的容错性比较高，例如，50的丢包率等价于使用b/2b带代替b进行分析；50的节点错误等价于使用n/2来代替nn，同时使用b/2来代替b进行分析，其分析结果不用带来数量级上的变化。</p>
<h4 id=gossip节点的通信方式>Gossip节点的通信方式</h4>
<p>根据原论文，两个节点（A、B）之间存在三种通信方式:</p>
<ul>
<li>push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据</li>
<li>pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地</li>
<li>push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地</li>
</ul>
<p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。</p>
<p>假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(log(n))$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第$i$个周期被感染的概率为$P_i$ ,第$i+1$个周期被感染的概率为$P^{i+1}$ ，则pull的方式:</p>
<blockquote>
<p>$P_{i+1}=P_i^{b+1}$</p>
</blockquote>
<p>而push为：</p>
<blockquote>
<p>$P_{i+1}=P_i(1-\frac{1}{n})^{n(1-P_i)}$</p>
</blockquote>
<p>显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0&lt;p&lt;1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。</p>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2017-04-26</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/fork-and-pipe/ class=prev rel=prev title="pipe and fork"><i class="fas fa-angle-left fa-fw"></i>pipe and fork</a>
<a href=/posts/cap%E7%90%86%E8%AE%BA/ class=next rel=next title=CAP理论>CAP理论<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.92.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div>
</div>
</footer></div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body>
</html>