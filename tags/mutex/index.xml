<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mutex on iofun</title><link>https://wangke1020.github.io/tags/mutex/</link><description>Recent content in mutex on iofun</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 12 Feb 2022 20:53:09 +0800</lastBuildDate><atom:link href="https://wangke1020.github.io/tags/mutex/index.xml" rel="self" type="application/rss+xml"/><item><title>Folly SharedMutex实现</title><link>https://wangke1020.github.io/posts/folly-sharedmutex/</link><pubDate>Sat, 12 Feb 2022 20:53:09 +0800</pubDate><guid>https://wangke1020.github.io/posts/folly-sharedmutex/</guid><description>在多线程并发读写开发中，尤其是读多写少的情况，使用读写锁代替普通mutex一般可以提升读并发度。 在多个线程频繁获取和释放读锁时，read lock count计数修改会反复触发cpu cacheline同步，导致实际性能可能达不到预期。folly SharedMutex 通过将reader信息存储在全局静态区域，来减少cacheline同步。
class structure 类定义 1 2 3 4 5 6 using Futex = std::atomic&amp;lt;std::uint32_t&amp;gt;; class SharedMutexImpl { // 32 bits of state Futex state_{}; } SharedMutexImpl 仅使用32位的atomic来存储读写锁内部状态 其中一些常用状态含义为（详见代码注释)
kIncrHasS = 1 &amp;laquo; 11, kHasS = ~(kIncrHasS - 1); 第11-31位表示shared lock计数, 每次增减 kIncrHasS。 kHasE = 1 &amp;laquo; 7; exlusive排它标志位 kBegunE = 1 &amp;laquo; 6; 开始获取写锁 kHasU = 1 &amp;laquo; 5; upgrade lock kMayDefer = 1 &amp;laquo; 9; 是否有读锁信息存储在全局静态区 Global Shared readers 1 2 3 4 5 6 constexpr uint32_t kMaxDeferredReadersAllocated = 256 * 2; static constexpr uint32_t kDeferredSeparationFactor = 4; typedef Atom&amp;lt;uintptr_t&amp;gt; DeferredReaderSlot; alignas(hardware_destructive_interference_size) static DeferredReaderSlot deferredReaders[shared_mutex_detail::kMaxDeferredReadersAllocated * kDeferredSeparationFactor]; deferredReaders定义为2048个cacheline对齐的DeferredReaderSlot，uintptr_t保存SharedMutex实例唯一的token，标记当前slot关联的SharedMutex被某个线程持有reader lock。</description></item></channel></rss>